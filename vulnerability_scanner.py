import requests
from urllib.parse import urlencode, urljoin
from bs4 import BeautifulSoup

class VulnerabilityScanner:
    def __init__(self, site_map, report_file):
        """
        Initialize the scanner with a site map and report file.
        """
        self.site_map = site_map
        self.report_file = report_file

    def run(self):
        """
        Run all vulnerability tests.
        """
        self.check_for_sql_injection()
        self.check_for_xss()
        self.check_insecure_headers()

    def log_and_report(self, message):
        """
        Log a vulnerability and write it to the report file.
        """
        print(message)
        self.report_file.write(f"{message}\n")

    def check_for_sql_injection(self):
        """
        Check for SQL injection vulnerabilities.
        """
        sql_payloads = [
            "'", "\"", "' OR 1=1--", "' AND 1=2--", "' OR 'a'='a'--",
            "' UNION SELECT null--", "' UNION SELECT 1,2,3--",
            "admin'--", "' OR '1'='1", "' AND 1=1#", "' OR 1=1#",
            "'; DROP TABLE users; --", "'; EXEC xp_cmdshell('whoami'); --"
        ]

        sql_errors = [
            "you have an error in your sql syntax",
            "sql syntax error",
            "unknown column",
            "sqlstate",
            "unclosed quotation mark",
            "odbc sql",
            "native client",
            "unexpected token",
            "unterminated string constant",
            "syntax error"
        ]

        found_vulnerability = False

        for url in self.site_map:
            for payload in sql_payloads:
                try:
                    params = {"test": payload} 
                    query_url = f"{url}?{urlencode(params)}"
                    response = requests.get(query_url, timeout=5)

                    # Check for common SQL error patterns
                    if any(error in response.text.lower() for error in sql_errors):
                        self.log_and_report(f"[!] SQL injection vulnerability found: {query_url}")
                        found_vulnerability = True
                except Exception as e:
                    self.log_and_report(f"[!] Error checking SQL injection at {url}: {e}")

        if not found_vulnerability:
            self.log_and_report("[+] No SQL injection vulnerabilities detected")

    def check_for_xss(self):
        """
        Check for XSS vulnerabilities.
        """
        xss_payloads = [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "<body onload=alert('XSS')>",
            "'><script>alert('XSS')</script>",
            "<svg/onload=alert('XSS')>",
            "<iframe src=javascript:alert('XSS')>",
            "<math><maction xlink:href=\"javascript:alert('XSS')\">",
            "<object type=\"text/html\" data=\"javascript:alert('XSS')\">"
        ]

        found_vulnerability = False

        for url in self.site_map:
            try:
                forms = self.extract_forms(url)
                for form in forms:
                    for payload in xss_payloads:
                        form_data = self.get_form_data(form, payload)
                        response = self.submit_form(form, form_data, url)

                        if payload in response.text:
                            self.log_and_report(f"[!] XSS vulnerability found at {url} with payload: {payload}")
                            found_vulnerability = True
            except Exception as e:
                self.log_and_report(f"[!] Error checking XSS at {url}: {e}")

        if not found_vulnerability:
            self.log_and_report("[+] No XSS vulnerabilities detected")

    def check_insecure_headers(self):
        """
        Check for insecure headers in the response from each URL.
        """
        required_headers = {
            "X-Content-Type-Options": "Prevents browsers from interpreting files as a different MIME type.",
            "X-Frame-Options": "Prevents clickjacking attacks by controlling whether the browser allows the site to be embedded in a frame.",
            "X-XSS-Protection": "Enables cross-site scripting (XSS) filtering in the browser.",
            "Strict-Transport-Security": "Forces secure (HTTPS) connections to the server.",
            "Content-Security-Policy": "Prevents a wide range of attacks by specifying trusted sources for content.",
            "Referrer-Policy": "Controls the amount of referrer information sent with requests.",
            "Permissions-Policy": "Controls which browser features and APIs can be used in the web page."
        }

        found_vulnerability = False

        for url in self.site_map:
            try:
                response = requests.head(url, timeout=5)
                headers = response.headers

                missing_headers = []

                for header in required_headers:
                    if header not in headers:
                        missing_headers.append(header)

                if missing_headers:
                    self.log_and_report(f"[!] Missing headers for {url}: {', '.join(missing_headers)}")
                    found_vulnerability = True
            except Exception as e:
                self.log_and_report(f"[!] Error checking headers for {url}: {e}")

        if not found_vulnerability:
            self.log_and_report("[+] All recommended security headers are present")


    @staticmethod
    def extract_forms(url):
        """
        Extract forms from a given URL using BeautifulSoup.
        """
        try:
            response = requests.get(url, timeout=5)
            soup = BeautifulSoup(response.text, "html.parser")
            forms = soup.find_all("form")  # Find all <form> tags
            return forms
        except Exception as e:
            print(f"Error extracting forms from {url}: {e}")
            return []

    @staticmethod
    def get_form_data(form, value):
        """
        Generate form data to inject into forms.
        """
        form_data = {}
        for input_field in form.find_all("input"):
            input_name = input_field.get("name")
            input_type = input_field.get("type")
            input_value = input_field.get("value")

            if input_type == "text" or input_type == "search":
                form_data[input_name] = value
            else:
                form_data[input_name] = input_value
        return form_data

    @staticmethod
    def submit_form(form, form_data, url):
        """
        Submit form data to the form's action URL.
        """
        action = form.get("action")
        method = form.get("method").lower()
        form_url = urljoin(url, action)

        if method == "post":
            response = requests.post(form_url, data=form_data)
        else:
            response = requests.get(form_url, params=form_data)
        return response
